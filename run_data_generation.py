# To add a new cell, type '# %%'
# To add a new markdown cell, type '# %% [markdown]'

# %%
from data_utils import *
from pdm_data_generation.pdmdb_generator import *

import pandas as pd

# %%

# Set path variables
ofile='./experiments/output_files/data/%s'
ifile='./experiments/input_data/%s'

# %%
# ############ Generate Data #####################
# ################################################
 
# #########################################
# Parameters setting for the generator
n_events = 10   # Number of events
events_per_pattern = 10  # Number of events per pattern
constraint_density = 0.5    # Percentaje of connected events that will have constraints (1 means all connections will have constraints, 0 the opposite)
min_start = 0   # Time of minimun start of an event
min_duration = 1    
max_duration = 300    # Max duration for a time constraint (5 hours=60*5=300).
# #########################################


# #########################################
# Parameters setting for the generation of sequences using the generator
n_sequences = 300    # Number of sequences to be generated
sequences_mean_lenght = 10  # Maximun length of a sequence
n_patterns = 1  # Number of patterns to generate
pattern_coverage = 1 # Percentaje of sequences covering each pattern
# #########################################

# nbitems: number of events // lp: number of events per pattern
generator=pdmdb_generator(nbitems=n_events, 
                            lp=events_per_pattern, 
                            dc=constraint_density, 
                            minstart=min_start, 
                            minduration=min_duration, 
                            maxduration=max_duration)

# sequences: stores all the chronicle sequences generated by the generator 
chro_sequences = generator.generate(nb=n_sequences, 
                                l=sequences_mean_lenght, 
                                npat=n_patterns, 
                                th=pattern_coverage)

# Stores all the sequences taken from each chronicle sequence of the variable chro_sequences
sequences=[s.seq for s in chro_sequences]

# The disturbed chronicles to be used for generating disturbed sequences
disturbed_chronicles = []

for c in generator.patterns:
    # Probability of: [1:removing items, 2:modifying constraints, 3:adding items]
    prob = [0,1,0]  # Set probability of modifying constraints to 1 and 0 for removing/adding
    # Generate disturbed a chronicle from chronicle c with probability prob
    disturbed_chronicle = generator.pattern_generator.generate_similar(c,prob)
    disturbed_chronicles.append(disturbed_chronicle)

# sequences: stores all the chronicle sequences generated by the generator 
disturbed_chro_sequences = generator.generate(nb=n_sequences, 
                                l=sequences_mean_lenght, 
                                npat=n_patterns, 
                                th=pattern_coverage,
                                patterns=disturbed_chronicles)

# Stores all the sequences taken from each chronicle sequence of the variable disturbed_chro_sequences
disturbed_sequences=[s.seq for s in disturbed_chro_sequences]

# %%

# Removes from sequences and disturbed_sequences all events equal to -1
sequences=filterseq(sequences)
disturbed_sequences=filterseq(disturbed_sequences)
# %% [markdown]
# ############ Saves Data #####################
# ################################################

# %%

# Serialize sequences of events
serialization2(sequences,ifile% "sequences.txt")
serialization2(disturbed_sequences, ifile% "disturbed_sequences.txt")

# %%

# Serialize sequences of events with time
serialization(sequences, ifile% "sequencesT.txt")
serialization(disturbed_sequences, ifile% "disturbed_sequencesT.txt")

# %%

# Save the sequences in objects so that they can be reused later
saveobj( ofile% "sequences.pick",sequences)
saveobj( ofile% "disturbed_sequences.pick",disturbed_sequences)

# %%
sequences = loadobj(ofile% "sequences.pick")
disturbed_sequences = loadobj(ofile% "disturbed_sequences.pick")


# %%

to_csv(sequences,ofile% "sequences.csv")

# %%

# sequences = loadobj(ofile% "sequences.pick")
# disturbed_sequences = loadobj(ofile% "disturbed_sequences.pick")

# print("======== SEQUENCES =======")
# seq_df=pd.DataFrame({'sequence':[], 'label':[]})
# seq_df.sequence=pd.Series(disturbed_sequences[:])
# # nbseq=len(seq_df.sequence)

# seq_df.label=pd.Series(len(disturbed_sequences[:])*[0])
# # print(seq_df.shape)
# # print(seq_df.head(10))

# %% [markdown]

# ######### ANALIZE GENERATED DATA ##########


# %%

# ############### Data Frame #################
# ###########################################

nbitems=50 #nb vocab
seqlen=10 #len ch
# p_seq0=[]
# p_seq1=[]
DB_seq=sequences[:]

# DB_seq[:]+p_seq0[:]+p_seq1[:]

times = []
events=[]

for i,seq in enumerate(DB_seq): #the rows are "ChID,sequence,TC"
    if len(seq)==0:
        continue
    for t,e in seq:
        events.append(e)
        times.append(t)

    # lines.append(evnts)
    # timeseqs.append(times)

print(len(events))
print(len(times))
# seq_df=pd.DataFrame({'event':events, 'time':times})
seq_df=pd.DataFrame({'event':events, 'time':times})

seq_df.head()

# s=seq_df.event=pd.Series(events)
# seq_df.time=pd.Series(times)

# # seq_df.sequence=pd.Series(DB_seq[:]+p_seq0[:]+p_seq1[:])

# s.value_counts()
# # seq_df.plot(kind='bar')


# %%

from matplotlib import pyplot

seq_df.plot()
pyplot.show()
# %%

from matplotlib import pyplot

from pandas import read_csv
from pandas import Grouper
from pandas import DataFrame
from pandas import to_datetime

import numpy as np

series = read_csv(ofile% "sequences.csv", index_col=0)

groups = series.groupby('Event')
# groups.first()
events = DataFrame()

for name, group in groups:
    # tvalues = []
    # for e in group:
    #     tvalues.extend(e)
    # events[name] = [i[0] for i in group.values]
    events[name] = np.asarray(group['Event'])

events.plot(subplots=True, legend=False)
pyplot.show()

# # series.set_index('Id', inplace=True)
# series.groupby('Event')['Time'].plot(subplots=True, legend=False)
# pyplot.show()


#  %%
series = read_csv(ofile% "sequences.csv")

axes = series.plot.line(subplots=True)
type(axes)

# lines = series.plot.line(x='Time', y='Event')

# %%
series.hist()
pyplot.show()

series.plot(kind='kde')
pyplot.show()
series['Time'].plot(kind='kde')
pyplot.show()
series['Event'].plot(kind='kde')
pyplot.show()
#  %%


# %%

print("======== SEQUENCES =======")
seq_df=pd.DataFrame({'sequence':[], 'label':[]})
seq_df.sequence=pd.Series(sequences[:])
# nbseq=len(seq_df.sequence)

seq_df.label=pd.Series(len(sequences[:])*[0])
# print(seq_df.shape)
# print(seq_df.head(10))

#for e in seq_df.sequence:
#    print(e)

# %%

dataset = seq_df.copy()

print("head:")
train_dataset = dataset.sample(frac=0.8,random_state=0)
train_dataset.head()
# train_dataset.index
train_dataset.index
# train_dataset.describe()
# train_dataset['sequence']
# train_dataset.iloc[3]

# train_stats = train_dataset.describe()
# train_stats.pop("sequence")
# train_stats = train_stats.transpose()
# train_stats


# %%

import seaborn as sns
sns.pairplot(train_dataset[["sequence", "label"]], diag_kind="kde")


# %%

print("tail:")
test_dataset = dataset.drop(train_dataset.index)
test_dataset.tail()







